<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(android.accounts.IAccountAuthenticatorResponse,java.lang.String,java.lang.String,[java.lang.String,android.os.Bundle)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void addAccountFromCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,android.os.Bundle)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void confirmCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,android.os.Bundle)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void editProperties(android.accounts.IAccountAuthenticatorResponse,java.lang.String)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void getAccountCredentialsForCloning(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void getAccountRemovalAllowed(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthToken(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String,android.os.Bundle)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthTokenLabel(android.accounts.IAccountAuthenticatorResponse,java.lang.String)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void hasFeatures(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,[java.lang.String)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.accounts.AbstractAccountAuthenticator.Transport: void updateCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String,android.os.Bundle)> -> _SOURCE_
android.permission.ACCOUNT_MANAGER
<android.hardware.location.ActivityRecognitionHardware: boolean disableActivityEvent(java.lang.String,int)> -> _SOURCE_
android.permission.LOCATION_HARDWARE
<android.hardware.location.ActivityRecognitionHardware: boolean enableActivityEvent(java.lang.String,int,long)> -> _SOURCE_
android.permission.LOCATION_HARDWARE
<android.hardware.location.ActivityRecognitionHardware: boolean flush()> -> _SOURCE_
android.permission.LOCATION_HARDWARE
<android.hardware.location.ActivityRecognitionHardware: java.lang.String[] getSupportedActivities()> -> _SOURCE_
android.permission.LOCATION_HARDWARE
<android.hardware.location.ActivityRecognitionHardware: boolean isActivitySupported(java.lang.String)> -> _SOURCE_
android.permission.LOCATION_HARDWARE
<android.hardware.location.ActivityRecognitionHardware: boolean registerSink(android.hardware.location.IActivityRecognitionHardwareSink)> -> _SOURCE_
android.permission.LOCATION_HARDWARE
<android.hardware.location.ActivityRecognitionHardware: boolean unregisterSink(android.hardware.location.IActivityRecognitionHardwareSink)> -> _SOURCE_
android.permission.LOCATION_HARDWARE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getCompleteVoiceMailNumber()> -> _SOURCE_
android.permission.CALL_PRIVILEGED
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getDeviceId(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getDeviceSvn(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getGroupIdLevel1(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getIccSerialNumber(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getIccSimChallengeResponse(int,int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getIsimChallengeResponse(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getIsimDomain()> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getIsimImpi()> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String[] getIsimImpu()> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getIsimIst()> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String[] getIsimPcscf()> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getLine1AlphaTag(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getLine1Number(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getMsisdn(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getSubscriberId(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getVoiceMailAlphaTag(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.PhoneSubInfoProxy: java.lang.String getVoiceMailNumber(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SMSDispatcher.MultipartSmsSenderCallback: void onSendMultipartSmsComplete(int,[int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SEND_RESPOND_VIA_MESSAGE, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.SubscriptionController: int addSubInfoRecord(java.lang.String,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: void clearDefaultsForInactiveSubIds()> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: int clearSubInfo()> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: int getActiveSubInfoCount(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: android.telephony.SubscriptionInfo getActiveSubscriptionInfo(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: android.telephony.SubscriptionInfo getActiveSubscriptionInfoForIccId(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: android.telephony.SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: java.util.List getActiveSubscriptionInfoList(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: int getAllSubInfoCount(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: java.util.List getAllSubInfoList(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: java.lang.String getSubscriptionProperty(int,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: int setDataRoaming(int,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: void setDefaultDataSubId(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: void setDefaultSmsSubId(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: void setDefaultVoiceSubId(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: int setDisplayName(java.lang.String,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: int setDisplayNameUsingSrc(java.lang.String,int,long)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: int setDisplayNumber(java.lang.String,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: int setIconTint(int,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.SubscriptionController: void setSubscriptionProperty(int,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.internal.telephony.UiccSmsController: boolean copyMessageToIccEfForSubscriber(int,java.lang.String,int,[byte,[byte)> -> _SOURCE_
android.permission.RECEIVE_SMS, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: boolean disableCellBroadcastForSubscriber(int,int,int)> -> _SOURCE_
android.permission.RECEIVE_SMS
<com.android.internal.telephony.UiccSmsController: boolean disableCellBroadcastRangeForSubscriber(int,int,int,int)> -> _SOURCE_
android.permission.RECEIVE_SMS
<com.android.internal.telephony.UiccSmsController: boolean enableCellBroadcastForSubscriber(int,int,int)> -> _SOURCE_
android.permission.RECEIVE_SMS
<com.android.internal.telephony.UiccSmsController: boolean enableCellBroadcastRangeForSubscriber(int,int,int,int)> -> _SOURCE_
android.permission.RECEIVE_SMS
<com.android.internal.telephony.UiccSmsController: java.util.List getAllMessagesFromIccEfForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.RECEIVE_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: void injectSmsPduForSubscriber(int,[byte,java.lang.String,android.app.PendingIntent)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.internal.telephony.UiccSmsController: void sendDataForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,int,[byte,android.app.PendingIntent,android.app.PendingIntent)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SEND_RESPOND_VIA_MESSAGE, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: void sendDataForSubscriberWithSelfPermissions(int,java.lang.String,java.lang.String,java.lang.String,int,[byte,android.app.PendingIntent,android.app.PendingIntent)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SEND_RESPOND_VIA_MESSAGE, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: void sendMultipartTextForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.List,java.util.List,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SEND_RESPOND_VIA_MESSAGE, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: void sendStoredMultipartText(int,java.lang.String,android.net.Uri,java.lang.String,java.util.List,java.util.List)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SEND_RESPOND_VIA_MESSAGE, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: void sendStoredText(int,java.lang.String,android.net.Uri,java.lang.String,android.app.PendingIntent,android.app.PendingIntent)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SEND_RESPOND_VIA_MESSAGE, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: void sendTextForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SEND_RESPOND_VIA_MESSAGE, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: void sendTextForSubscriberWithSelfPermissions(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SEND_RESPOND_VIA_MESSAGE, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.internal.telephony.UiccSmsController: boolean updateMessageOnIccEfForSubscriber(int,java.lang.String,int,int,[byte)> -> _SOURCE_
android.permission.RECEIVE_SMS, android.permission.SEND_SMS, android.permission.UPDATE_APP_OPS_STATS
<com.android.nfc.NfcService.NfcAdapterService: void addNfcUnlockHandler(android.nfc.INfcUnlockHandler,[int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: boolean disable(boolean)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: boolean disableNdefPush()> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: void dispatch(android.nfc.Tag)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: boolean enable()> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: boolean enableNdefPush()> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: void invokeBeam()> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.NfcAdapterService: void invokeBeamInternal(android.nfc.BeamShareData)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: void pausePolling(int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: void resumePolling()> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: void setAppCallback(android.nfc.IAppCallback)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.NfcAdapterService: void setForegroundDispatch(android.app.PendingIntent,[android.content.IntentFilter,android.nfc.TechListParcel)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.NfcAdapterService: void setP2pModes(int,int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.NfcService.NfcAdapterService: void verifyNfcPermission()> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: int close(int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: int connect(int,int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: int formatNdef(int,[byte)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: I[] getTechList(int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: int getTimeout(int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: boolean isNdef(int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: int ndefMakeReadOnly(int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: android.nfc.NdefMessage ndefRead(int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: int ndefWrite(int,android.nfc.NdefMessage)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: int reconnect(int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: android.nfc.Tag rediscover(int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: void resetTimeouts()> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: int setTimeout(int,int)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.NfcService.TagService: android.nfc.TransceiveResult transceive(int,[byte,boolean)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: android.nfc.cardemulation.AidGroup getAidGroupForService(int,android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: java.util.List getServices(int,java.lang.String)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: boolean isDefaultServiceForAid(int,android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: boolean isDefaultServiceForCategory(int,android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: boolean registerAidGroupForService(int,android.content.ComponentName,android.nfc.cardemulation.AidGroup)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: boolean removeAidGroupForService(int,android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: boolean setDefaultForNextTap(int,android.content.ComponentName)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: boolean setDefaultServiceForCategory(int,android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: boolean setPreferredService(android.content.ComponentName)> -> _SOURCE_
android.permission.NFC
<com.android.nfc.cardemulation.CardEmulationManager.CardEmulationInterface: boolean unsetPreferredService()> -> _SOURCE_
android.permission.NFC
<com.android.phone.CarrierConfigLoader: android.os.PersistableBundle getConfigForSubId(int)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.CarrierConfigLoader: void updateConfigForPhoneId(int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void answerRingingCall()> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void answerRingingCallForSubscriber(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void call(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CALL_PHONE
<com.android.phone.PhoneInterfaceManager: boolean canChangeDtmfToneLength()> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean disableDataConnectivity()> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void disableLocationUpdates()> -> _SOURCE_
android.permission.CONTROL_LOCATION_UPDATES
<com.android.phone.PhoneInterfaceManager: void disableLocationUpdatesForSubscriber(int)> -> _SOURCE_
android.permission.CONTROL_LOCATION_UPDATES
<com.android.phone.PhoneInterfaceManager: boolean enableDataConnectivity()> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void enableLocationUpdates()> -> _SOURCE_
android.permission.CONTROL_LOCATION_UPDATES
<com.android.phone.PhoneInterfaceManager: void enableLocationUpdatesForSubscriber(int)> -> _SOURCE_
android.permission.CONTROL_LOCATION_UPDATES
<com.android.phone.PhoneInterfaceManager: void enableVideoCalling(boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean endCall()> -> _SOURCE_
android.permission.CALL_PHONE
<com.android.phone.PhoneInterfaceManager: boolean endCallForSubscriber(int)> -> _SOURCE_
android.permission.CALL_PHONE
<com.android.phone.PhoneInterfaceManager: void factoryReset(int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL, android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.util.List getAllCellInfo(java.lang.String)> -> _SOURCE_
android.permission.ACCESS_FINE_LOCATION
<com.android.phone.PhoneInterfaceManager: int getCalculatedPreferredNetworkType(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getCdmaEriIconIndex(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getCdmaEriIconIndexForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getCdmaEriIconMode(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getCdmaEriIconModeForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String getCdmaEriText(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String getCdmaEriTextForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String getCdmaMdn(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String getCdmaMin(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: android.os.Bundle getCellLocation(java.lang.String)> -> _SOURCE_
android.permission.ACCESS_FINE_LOCATION
<com.android.phone.PhoneInterfaceManager: com.android.internal.telephony.CellNetworkScanResult getCellNetworkScanResults(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean getDataEnabled(int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.phone.PhoneInterfaceManager: int getDataNetworkType(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getDataNetworkTypeForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String getDeviceId(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String getLine1AlphaTagForDisplay(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String getLine1NumberForDisplay(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getLteOnCdmaMode(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getLteOnCdmaModeForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String[] getMergedSubscriberIds(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.util.List getNeighboringCellInfo(java.lang.String)> -> _SOURCE_
android.permission.ACCESS_FINE_LOCATION
<com.android.phone.PhoneInterfaceManager: int getNetworkTypeForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String[] getPcscfAddress(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getPreferredNetworkType(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getRadioAccessFamily(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getTetherApnRequired()> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int getVoiceNetworkTypeForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean handlePinMmi(java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean handlePinMmiForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean iccCloseLogicalChannel(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: B[] iccExchangeSimIO(int,int,int,int,int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: android.telephony.IccOpenLogicalChannelResponse iccOpenLogicalChannel(java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String iccTransmitApduBasicChannel(int,int,int,int,int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String iccTransmitApduLogicalChannel(int,int,int,int,int,int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: int invokeOemRilRequestRaw([byte,[byte)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isIdle(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isIdleForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isOffhook(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isOffhookForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isRadioOn(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isRadioOnForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isRinging(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isRingingForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isSimPinEnabled(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isVideoCallingEnabled(java.lang.String)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean isWorldPhone()> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String nvReadItem(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean nvResetConfig(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean nvWriteCdmaPrl([byte)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean nvWriteItem(int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: java.lang.String sendEnvelopeWithStatus(java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void setDataEnabled(int,boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void setImsRegistrationState(boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void setNetworkSelectionModeAutomatic(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean setNetworkSelectionModeManual(int,com.android.internal.telephony.OperatorInfo,boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean setPreferredNetworkType(int,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean setRadio(boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean setRadioForSubscriber(int,boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean setRadioPower(boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void shutdownMobileRadios()> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean supplyPin(java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean supplyPinForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: I[] supplyPinReportResult(java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: I[] supplyPinReportResultForSubscriber(int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean supplyPuk(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: boolean supplyPukForSubscriber(int,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: I[] supplyPukReportResult(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: I[] supplyPukReportResultForSubscriber(int,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void toggleRadioOnOff()> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.phone.PhoneInterfaceManager: void toggleRadioOnOffForSubscriber(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.providers.contacts.ContactsProvider2: java.lang.String getType(android.net.Uri)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS
<com.android.providers.contacts.ContactsProvider2: java.lang.String getType(android.net.Uri)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS
<com.android.providers.contacts.ContactsProvider2: java.lang.String getType(android.net.Uri)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS
<com.android.server.AppOpsService: int checkAudioOperation(int,int,int,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.AppOpsService: int checkOperation(int,int,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.AppOpsService: void finishOperation(android.os.IBinder,int,int,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.AppOpsService: java.util.List getOpsForPackage(int,java.lang.String,[int)> -> _SOURCE_
android.permission.GET_APP_OPS_STATS
<com.android.server.AppOpsService: java.util.List getPackagesForOps([int)> -> _SOURCE_
android.permission.GET_APP_OPS_STATS
<com.android.server.AppOpsService: int noteOperation(int,int,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.AppOpsService: void resetAllModes(int,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.AppOpsService: void setAudioRestriction(int,int,int,int,[java.lang.String)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.AppOpsService: void setMode(int,int,java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.AppOpsService: void setUidMode(int,int,int)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.AppOpsService: int startOperation(android.os.IBinder,int,int,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS
<com.android.server.BluetoothManagerService: boolean disable(boolean)> -> _SOURCE_
android.permission.BLUETOOTH_ADMIN
<com.android.server.BluetoothManagerService: boolean enable()> -> _SOURCE_
android.permission.BLUETOOTH_ADMIN
<com.android.server.BluetoothManagerService: boolean enableNoAutoConnect()> -> _SOURCE_
android.permission.BLUETOOTH_ADMIN
<com.android.server.BluetoothManagerService: java.lang.String getAddress()> -> _SOURCE_
android.permission.BLUETOOTH, android.permission.LOCAL_MAC_ADDRESS
<com.android.server.BluetoothManagerService: java.lang.String getName()> -> _SOURCE_
android.permission.BLUETOOTH
<com.android.server.BluetoothManagerService: void registerStateChangeCallback(android.bluetooth.IBluetoothStateChangeCallback)> -> _SOURCE_
android.permission.BLUETOOTH
<com.android.server.BluetoothManagerService: void unregisterAdapter(android.bluetooth.IBluetoothManagerCallback)> -> _SOURCE_
android.permission.BLUETOOTH
<com.android.server.BluetoothManagerService: void unregisterStateChangeCallback(android.bluetooth.IBluetoothStateChangeCallback)> -> _SOURCE_
android.permission.BLUETOOTH
<com.android.server.ConnectivityService: void factoryReset()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL, android.permission.CONTROL_VPN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.ConnectivityService: android.net.LinkProperties getActiveLinkProperties()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.Network getActiveNetwork()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.NetworkInfo getActiveNetworkInfo()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.NetworkInfo getActiveNetworkInfoForUid(int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: android.net.NetworkQuotaInfo getActiveNetworkQuotaInfo()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.NetworkInfo[] getAllNetworkInfo()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.NetworkState[] getAllNetworkState()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: android.net.Network[] getAllNetworks()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: com.android.internal.net.VpnInfo[] getAllVpnInfo()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: android.net.NetworkCapabilities[] getDefaultNetworkCapabilitiesForUser(int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: int getLastTetherError(java.lang.String)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: com.android.internal.net.LegacyVpnInfo getLegacyVpnInfo(int)> -> _SOURCE_
android.permission.CONTROL_VPN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.ConnectivityService: android.net.LinkProperties getLinkProperties(android.net.Network)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.LinkProperties getLinkPropertiesForType(int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: java.lang.String getMobileProvisioningUrl()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: android.net.NetworkCapabilities getNetworkCapabilities(android.net.Network)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.Network getNetworkForType(int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.NetworkInfo getNetworkInfo(int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.NetworkInfo getNetworkInfoForNetwork(android.net.Network)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: java.lang.String[] getTetherableBluetoothRegexs()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: java.lang.String[] getTetherableIfaces()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: java.lang.String[] getTetherableUsbRegexs()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: java.lang.String[] getTetherableWifiRegexs()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: java.lang.String[] getTetheredDhcpRanges()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: java.lang.String[] getTetheredIfaces()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: java.lang.String[] getTetheringErroredIfaces()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: com.android.internal.net.VpnConfig getVpnConfig(int)> -> _SOURCE_
android.permission.CONTROL_VPN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.ConnectivityService: boolean isActiveNetworkMetered()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: boolean isNetworkSupported(int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: boolean isTetheringSupported()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.NetworkRequest listenForNetwork(android.net.NetworkCapabilities,android.os.Messenger,android.os.IBinder)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.ACCESS_WIFI_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void pendingListenForNetwork(android.net.NetworkCapabilities,android.app.PendingIntent)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.ACCESS_WIFI_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: android.net.NetworkRequest pendingRequestForNetwork(android.net.NetworkCapabilities,android.app.PendingIntent)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: boolean prepareVpn(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.CONTROL_VPN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.ConnectivityService: int registerNetworkAgent(android.os.Messenger,android.net.NetworkInfo,android.net.LinkProperties,android.net.NetworkCapabilities,int,android.net.NetworkMisc)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void registerNetworkFactory(android.os.Messenger,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void reportInetCondition(int,int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.INTERNET
<com.android.server.ConnectivityService: void reportNetworkConnectivity(android.net.Network,boolean)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.INTERNET
<com.android.server.ConnectivityService: boolean requestBandwidthUpdate(android.net.Network)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.ConnectivityService: android.net.NetworkRequest requestNetwork(android.net.NetworkCapabilities,android.os.Messenger,int,android.os.IBinder,int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: boolean requestRouteToHostAddress(int,[byte)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void setAcceptUnvalidated(android.net.Network,boolean,boolean)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void setAirplaneMode(boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void setGlobalProxy(android.net.ProxyInfo)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void setProvisioningNotificationVisible(boolean,int,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: int setUsbTethering(boolean)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: int setUsbTethering(boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void setVpnPackageAuthorization(java.lang.String,int,boolean)> -> _SOURCE_
android.permission.CONTROL_VPN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.ConnectivityService: void startLegacyVpn(com.android.internal.net.VpnProfile)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONTROL_VPN
<com.android.server.ConnectivityService: void startNattKeepalive(android.net.Network,int,android.os.Messenger,android.os.IBinder,java.lang.String,int,java.lang.String)> -> _SOURCE_
android.permission.PACKET_KEEPALIVE_OFFLOAD
<com.android.server.ConnectivityService: int tether(java.lang.String)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: int tether(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: void unregisterNetworkFactory(android.os.Messenger)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: int untether(java.lang.String)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: int untether(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConnectivityService: boolean updateLockdownVpn()> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE, android.permission.CONNECTIVITY_INTERNAL
<com.android.server.ConsumerIrService: I[] getCarrierFrequencies()> -> _SOURCE_
android.permission.TRANSMIT_IR
<com.android.server.ConsumerIrService: void transmit(java.lang.String,int,[int)> -> _SOURCE_
android.permission.TRANSMIT_IR
<com.android.server.DeviceIdleController.BinderService: void addPowerSaveTempWhitelistApp(java.lang.String,long,int,java.lang.String)> -> _SOURCE_
android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST
<com.android.server.DeviceIdleController.BinderService: long addPowerSaveTempWhitelistAppForMms(java.lang.String,int,java.lang.String)> -> _SOURCE_
android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST
<com.android.server.DeviceIdleController.BinderService: long addPowerSaveTempWhitelistAppForSms(java.lang.String,int,java.lang.String)> -> _SOURCE_
android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST
<com.android.server.DeviceIdleController.BinderService: void addPowerSaveWhitelistApp(java.lang.String)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.DeviceIdleController.BinderService: void exitIdle(java.lang.String)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.DeviceIdleController.BinderService: void removePowerSaveWhitelistApp(java.lang.String)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.DropBoxManagerService: android.os.DropBoxManager$Entry getNextEntry(java.lang.String,long)> -> _SOURCE_
android.permission.READ_LOGS
<com.android.server.InputMethodManagerService: void addClient(com.android.internal.view.IInputMethodClient,com.android.internal.view.IInputContext,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: android.view.inputmethod.InputMethodSubtype getCurrentInputMethodSubtype()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: java.util.List getEnabledInputMethodList()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: java.util.List getEnabledInputMethodSubtypeList(java.lang.String,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: java.util.List getInputMethodList()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: android.view.inputmethod.InputMethodSubtype getLastInputMethodSubtype()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: void hideMySoftInput(android.os.IBinder,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: boolean hideSoftInput(com.android.internal.view.IInputMethodClient,int,android.os.ResultReceiver)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: boolean notifySuggestionPicked(android.text.style.SuggestionSpan,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: void registerSuggestionSpansForNotification([android.text.style.SuggestionSpan)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: void removeClient(com.android.internal.view.IInputMethodClient)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: void setAdditionalInputMethodSubtypes(java.lang.String,[android.view.inputmethod.InputMethodSubtype)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: boolean setCurrentInputMethodSubtype(android.view.inputmethod.InputMethodSubtype)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: void setImeWindowStatus(android.os.IBinder,int,int)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.InputMethodManagerService: void setInputMethod(android.os.IBinder,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SECURE_SETTINGS
<com.android.server.InputMethodManagerService: void setInputMethodAndSubtype(android.os.IBinder,java.lang.String,android.view.inputmethod.InputMethodSubtype)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SECURE_SETTINGS
<com.android.server.InputMethodManagerService: boolean setInputMethodEnabled(java.lang.String,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SECURE_SETTINGS
<com.android.server.InputMethodManagerService: boolean shouldOfferSwitchingToNextInputMethod(android.os.IBinder)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: void showInputMethodAndSubtypeEnablerFromClient(com.android.internal.view.IInputMethodClient,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.STATUS_BAR
<com.android.server.InputMethodManagerService: void showInputMethodPickerFromClient(com.android.internal.view.IInputMethodClient,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: void showMySoftInput(android.os.IBinder,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: boolean showSoftInput(com.android.internal.view.IInputMethodClient,int,android.os.ResultReceiver)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.InputMethodManagerService: com.android.internal.view.InputBindResult startInput(com.android.internal.view.IInputMethodClient,com.android.internal.view.IInputContext,android.view.inputmethod.EditorInfo,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.STATUS_BAR
<com.android.server.InputMethodManagerService: boolean switchToLastInputMethod(android.os.IBinder)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SECURE_SETTINGS
<com.android.server.InputMethodManagerService: boolean switchToNextInputMethod(android.os.IBinder,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SECURE_SETTINGS
<com.android.server.InputMethodManagerService: void updateStatusIcon(android.os.IBinder,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.STATUS_BAR
<com.android.server.InputMethodManagerService: com.android.internal.view.InputBindResult windowGainedFocus(com.android.internal.view.IInputMethodClient,android.os.IBinder,int,int,int,android.view.inputmethod.EditorInfo,com.android.internal.view.IInputContext)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.STATUS_BAR
<com.android.server.LocationManagerService: boolean addGpsMeasurementsListener(android.location.IGpsMeasurementsListener,java.lang.String)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: boolean addGpsNavigationMessageListener(android.location.IGpsNavigationMessageListener,java.lang.String)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: boolean addGpsStatusListener(android.location.IGpsStatusListener,java.lang.String)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: java.lang.String getBestProvider(android.location.Criteria,boolean)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: android.location.Location getLastLocation(android.location.LocationRequest,java.lang.String)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: com.android.internal.location.ProviderProperties getProviderProperties(java.lang.String)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: java.util.List getProviders(android.location.Criteria,boolean)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: void removeUpdates(android.location.ILocationListener,android.app.PendingIntent,java.lang.String)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: void reportLocation(android.location.Location,boolean)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION, android.permission.INSTALL_LOCATION_PROVIDER
<com.android.server.LocationManagerService: void requestGeofence(android.location.LocationRequest,android.location.Geofence,android.app.PendingIntent,java.lang.String)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION
<com.android.server.LocationManagerService: void requestLocationUpdates(android.location.LocationRequest,android.location.ILocationListener,android.app.PendingIntent,java.lang.String)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION, android.permission.UPDATE_APP_OPS_STATS, android.permission.UPDATE_DEVICE_STATS
<com.android.server.LocationManagerService: boolean sendExtraCommand(java.lang.String,java.lang.String,android.os.Bundle)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.ACCESS_FINE_LOCATION, android.permission.ACCESS_LOCATION_EXTRA_COMMANDS
<com.android.server.LockSettingsService: com.android.internal.widget.VerifyCredentialResponse checkPassword(java.lang.String,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: com.android.internal.widget.VerifyCredentialResponse checkPattern(java.lang.String,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: boolean checkVoldPassword(int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: boolean getBoolean(java.lang.String,boolean,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE, android.permission.READ_CONTACTS
<com.android.server.LockSettingsService: long getLong(java.lang.String,long,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE, android.permission.READ_CONTACTS
<com.android.server.LockSettingsService: java.lang.String getString(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE, android.permission.READ_CONTACTS
<com.android.server.LockSettingsService: void registerStrongAuthTracker(android.app.trust.IStrongAuthTracker)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: void requireStrongAuth(int,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: void setBoolean(java.lang.String,boolean,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: void setLockPassword(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: void setLockPattern(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: void setLong(java.lang.String,long,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: void setString(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: void unregisterStrongAuthTracker(android.app.trust.IStrongAuthTracker)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: com.android.internal.widget.VerifyCredentialResponse verifyPassword(java.lang.String,long,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.LockSettingsService: com.android.internal.widget.VerifyCredentialResponse verifyPattern(java.lang.String,long,int)> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.MmsServiceBroker.BinderService: void downloadMessage(int,java.lang.String,java.lang.String,android.net.Uri,android.os.Bundle,android.app.PendingIntent)> -> _SOURCE_
android.permission.RECEIVE_MMS
<com.android.server.MmsServiceBroker.BinderService: void sendMessage(int,java.lang.String,android.net.Uri,java.lang.String,android.os.Bundle,android.app.PendingIntent)> -> _SOURCE_
android.permission.SEND_SMS
<com.android.server.MountService: long benchmark(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_FORMAT_FILESYSTEMS
<com.android.server.MountService: int changeEncryptionPassword(int,java.lang.String)> -> _SOURCE_
android.permission.CRYPT_KEEPER
<com.android.server.MountService: int createSecureContainer(java.lang.String,int,java.lang.String,java.lang.String,int,boolean)> -> _SOURCE_
android.permission.ASEC_CREATE
<com.android.server.MountService: int decryptStorage(java.lang.String)> -> _SOURCE_
android.permission.CRYPT_KEEPER
<com.android.server.MountService: int destroySecureContainer(java.lang.String,boolean)> -> _SOURCE_
android.permission.ASEC_DESTROY
<com.android.server.MountService: int encryptStorage(int,java.lang.String)> -> _SOURCE_
android.permission.CRYPT_KEEPER
<com.android.server.MountService: int finalizeSecureContainer(java.lang.String)> -> _SOURCE_
android.permission.ASEC_CREATE
<com.android.server.MountService: int fixPermissionsSecureContainer(java.lang.String,int,java.lang.String)> -> _SOURCE_
android.permission.ASEC_CREATE
<com.android.server.MountService: void forgetAllVolumes()> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: void forgetVolume(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: void format(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_FORMAT_FILESYSTEMS
<com.android.server.MountService: int formatVolume(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_FORMAT_FILESYSTEMS
<com.android.server.MountService: int getEncryptionState()> -> _SOURCE_
android.permission.CRYPT_KEEPER
<com.android.server.MountService: java.lang.String getPassword()> -> _SOURCE_
android.permission.ACCESS_KEYGUARD_SECURE_STORAGE
<com.android.server.MountService: java.lang.String getPrimaryStorageUuid()> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: java.lang.String getSecureContainerFilesystemPath(java.lang.String)> -> _SOURCE_
android.permission.ASEC_ACCESS
<com.android.server.MountService: java.lang.String[] getSecureContainerList()> -> _SOURCE_
android.permission.ASEC_ACCESS
<com.android.server.MountService: java.lang.String getSecureContainerPath(java.lang.String)> -> _SOURCE_
android.permission.ASEC_ACCESS
<com.android.server.MountService: I[] getStorageUsers(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: boolean isSecureContainerMounted(java.lang.String)> -> _SOURCE_
android.permission.ASEC_ACCESS
<com.android.server.MountService: void mount(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: int mountSecureContainer(java.lang.String,java.lang.String,int,boolean)> -> _SOURCE_
android.permission.ASEC_MOUNT_UNMOUNT
<com.android.server.MountService: int mountVolume(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: void partitionMixed(java.lang.String,int)> -> _SOURCE_
android.permission.MOUNT_FORMAT_FILESYSTEMS
<com.android.server.MountService: void partitionPrivate(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_FORMAT_FILESYSTEMS
<com.android.server.MountService: void partitionPublic(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_FORMAT_FILESYSTEMS
<com.android.server.MountService: int renameSecureContainer(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.ASEC_RENAME
<com.android.server.MountService: int resizeSecureContainer(java.lang.String,int,java.lang.String)> -> _SOURCE_
android.permission.ASEC_CREATE
<com.android.server.MountService: void runMaintenance()> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: void setDebugFlags(int,int)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: void setPrimaryStorageUuid(java.lang.String,android.content.pm.IPackageMoveObserver)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: void setVolumeNickname(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: void setVolumeUserFlags(java.lang.String,int,int)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: void shutdown(android.os.storage.IMountShutdownObserver)> -> _SOURCE_
android.permission.SHUTDOWN
<com.android.server.MountService: void unmount(java.lang.String)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: int unmountSecureContainer(java.lang.String,boolean)> -> _SOURCE_
android.permission.ASEC_MOUNT_UNMOUNT
<com.android.server.MountService: void unmountVolume(java.lang.String,boolean,boolean)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.MountService: int verifyEncryptionPassword(java.lang.String)> -> _SOURCE_
android.permission.CRYPT_KEEPER
<com.android.server.NetworkManagementService: void addIdleTimer(java.lang.String,int,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void addInterfaceToLocalNetwork(java.lang.String,java.util.List)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void addInterfaceToNetwork(java.lang.String,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void addLegacyRouteForNetId(int,android.net.RouteInfo,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void addRoute(int,android.net.RouteInfo)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void addVpnUidRanges(int,[android.net.UidRange)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void allowProtect(int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void attachPppd(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void clearDefaultNetId()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void clearInterfaceAddresses(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void clearPermission([int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void createPhysicalNetwork(int,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void createVirtualNetwork(int,boolean,boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void denyProtect(int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void detachPppd(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void disableIpv6(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void disableNat(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void enableIpv6(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void enableNat(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void flushNetworkDnsCache(int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: java.lang.String[] getDnsForwarders()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: android.net.InterfaceConfiguration getInterfaceConfig(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: boolean getIpForwardingEnabled()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: android.net.NetworkStats getNetworkStatsDetail()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: android.net.NetworkStats getNetworkStatsSummaryDev()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: android.net.NetworkStats getNetworkStatsSummaryXt()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: android.net.NetworkStats getNetworkStatsTethering()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: android.net.NetworkStats getNetworkStatsUidDetail(int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: android.net.RouteInfo[] getRoutes(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: boolean isBandwidthControlEnabled()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: boolean isClatdStarted(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: boolean isTetheringStarted()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: java.lang.String[] listInterfaces()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: java.lang.String[] listTetheredInterfaces()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: java.lang.String[] listTtys()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void registerObserver(android.net.INetworkManagementEventObserver)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void removeIdleTimer(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void removeInterfaceAlert(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void removeInterfaceFromLocalNetwork(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void removeInterfaceFromNetwork(java.lang.String,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void removeInterfaceQuota(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void removeNetwork(int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void removeRoute(int,android.net.RouteInfo)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void removeVpnUidRanges(int,[android.net.UidRange)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setAccessPoint(android.net.wifi.WifiConfiguration,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setDefaultNetId(int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setDnsForwarders(android.net.Network,[java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setDnsServersForNetwork(int,[java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setGlobalAlert(long)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setInterfaceAlert(java.lang.String,long)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setInterfaceConfig(java.lang.String,android.net.InterfaceConfiguration)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setInterfaceDown(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setInterfaceIpv6NdOffload(java.lang.String,boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setInterfaceIpv6PrivacyExtensions(java.lang.String,boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setInterfaceQuota(java.lang.String,long)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setInterfaceUp(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setIpForwardingEnabled(boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setMtu(java.lang.String,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setNetworkPermission(int,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setPermission(java.lang.String,[int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setUidCleartextNetworkPolicy(int,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void setUidNetworkRules(int,boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void shutdown()> -> _SOURCE_
android.permission.SHUTDOWN
<com.android.server.NetworkManagementService: void startAccessPoint(android.net.wifi.WifiConfiguration,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void startClatd(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void startInterfaceForwarding(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void startTethering([java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void stopAccessPoint(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void stopClatd(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void stopInterfaceForwarding(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void stopTethering()> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void tetherInterface(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void unregisterObserver(android.net.INetworkManagementEventObserver)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void untetherInterface(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkManagementService: void wifiFirmwareReload(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.NetworkScoreService: boolean clearScores()> -> _SOURCE_
android.permission.BROADCAST_NETWORK_PRIVILEGED, android.permission.SCORE_NETWORKS
<com.android.server.NetworkScoreService: void disableScoring()> -> _SOURCE_
android.permission.BROADCAST_NETWORK_PRIVILEGED, android.permission.SCORE_NETWORKS
<com.android.server.NetworkScoreService: void registerNetworkScoreCache(int,android.net.INetworkScoreCache)> -> _SOURCE_
android.permission.BROADCAST_NETWORK_PRIVILEGED
<com.android.server.NetworkScoreService: boolean setActiveScorer(java.lang.String)> -> _SOURCE_
android.permission.SCORE_NETWORKS
<com.android.server.NetworkScoreService: boolean updateScores([android.net.ScoredNetwork)> -> _SOURCE_
android.permission.SCORE_NETWORKS
<com.android.server.NsdService: android.os.Messenger getMessenger()> -> _SOURCE_
android.permission.INTERNET
<com.android.server.NsdService: void setEnabled(boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.SerialService: java.lang.String[] getSerialPorts()> -> _SOURCE_
android.permission.SERIAL_PORT
<com.android.server.SerialService: android.os.ParcelFileDescriptor openSerialPort(java.lang.String)> -> _SOURCE_
android.permission.SERIAL_PORT
<com.android.server.TelephonyRegistry: void addOnSubscriptionsChangedListener(java.lang.String,com.android.internal.telephony.IOnSubscriptionsChangedListener)> -> _SOURCE_
android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.server.TelephonyRegistry: void listen(java.lang.String,com.android.internal.telephony.IPhoneStateListener,int,boolean)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.READ_PHONE_STATE, android.permission.READ_PRECISE_PHONE_STATE, android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.server.TelephonyRegistry: void listenForSubscriber(int,java.lang.String,com.android.internal.telephony.IPhoneStateListener,int,boolean)> -> _SOURCE_
android.permission.ACCESS_COARSE_LOCATION, android.permission.READ_PHONE_STATE, android.permission.READ_PRECISE_PHONE_STATE, android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCallForwardingChanged(boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCallForwardingChangedForSubscriber(int,boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCallState(int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCallStateForSubscriber(int,int,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCarrierNetworkChange(boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCellInfo(java.util.List)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCellInfoForSubscriber(int,java.util.List)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCellLocation(android.os.Bundle)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyCellLocationForSubscriber(int,android.os.Bundle)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyDataActivity(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyDataActivityForSubscriber(int,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyDataConnection(int,boolean,java.lang.String,java.lang.String,java.lang.String,android.net.LinkProperties,android.net.NetworkCapabilities,int,boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyDataConnectionFailed(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyDataConnectionFailedForSubscriber(int,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyDataConnectionForSubscriber(int,int,boolean,java.lang.String,java.lang.String,java.lang.String,android.net.LinkProperties,android.net.NetworkCapabilities,int,boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyDataConnectionRealTimeInfo(android.telephony.DataConnectionRealTimeInfo)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyDisconnectCause(int,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyMessageWaitingChangedForPhoneId(int,int,boolean)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyOemHookRawEventForSubscriber(int,[byte)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyOtaspChanged(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyPreciseCallState(int,int,int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyPreciseDataConnectionFailed(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyServiceStateForPhoneId(int,int,android.telephony.ServiceState)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifySignalStrength(android.telephony.SignalStrength)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifySignalStrengthForSubscriber(int,android.telephony.SignalStrength)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TelephonyRegistry: void notifyVoLteServiceStateChanged(android.telephony.VoLteServiceState)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.TextServicesManagerService: void setCurrentSpellChecker(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.TextServicesManagerService: void setCurrentSpellCheckerSubtype(java.lang.String,int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.TextServicesManagerService: void setSpellCheckerEnabled(boolean)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.UpdateLockService: void acquireUpdateLock(android.os.IBinder,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_LOCK
<com.android.server.UpdateLockService: void releaseUpdateLock(android.os.IBinder)> -> _SOURCE_
android.permission.UPDATE_LOCK
<com.android.server.VibratorService: void cancelVibrate(android.os.IBinder)> -> _SOURCE_
android.permission.VIBRATE
<com.android.server.VibratorService: void vibrate(int,java.lang.String,long,int,android.os.IBinder)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS, android.permission.VIBRATE
<com.android.server.VibratorService: void vibratePattern(int,java.lang.String,[long,int,int,android.os.IBinder)> -> _SOURCE_
android.permission.UPDATE_APP_OPS_STATS, android.permission.VIBRATE
<com.android.server.accounts.AccountManagerService: void addAccountAsUser(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String,[java.lang.String,boolean,android.os.Bundle,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: void confirmCredentialsAsUser(android.accounts.IAccountManagerResponse,android.accounts.Account,android.os.Bundle,boolean,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: void copyAccountToUser(android.accounts.IAccountManagerResponse,android.accounts.Account,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: android.accounts.Account[] getAccounts(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: android.accounts.Account[] getAccountsAsUser(java.lang.String,int,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: android.accounts.Account[] getAccountsByTypeForPackage(java.lang.String,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: android.accounts.Account[] getAccountsForPackage(java.lang.String,int,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: android.accounts.AuthenticatorDescription[] getAuthenticatorTypes(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: void removeAccount(android.accounts.IAccountManagerResponse,android.accounts.Account,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.accounts.AccountManagerService: void removeAccountAsUser(android.accounts.IAccountManagerResponse,android.accounts.Account,boolean,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.am.ActivityManagerService: void appNotRespondingViaProvider(android.os.IBinder)> -> _SOURCE_
android.permission.REMOVE_TASKS
<com.android.server.am.ActivityManagerService: boolean bindBackupAgent(android.content.pm.ApplicationInfo,int)> -> _SOURCE_
android.permission.CONFIRM_FULL_BACKUP
<com.android.server.am.ActivityManagerService: void bootAnimationComplete()> -> _SOURCE_
android.permission.BROADCAST_STICKY
<com.android.server.am.ActivityManagerService: void clearPendingBackup()> -> _SOURCE_
android.permission.BACKUP
<com.android.server.am.ActivityManagerService: void crashApplication(int,int,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.FORCE_STOP_PACKAGES
<com.android.server.am.ActivityManagerService: android.app.IActivityContainer createStackOnDisplay(int)> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: android.app.IActivityContainer createVirtualActivityContainer(android.os.IBinder,android.app.IActivityContainerCallback)> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: void deleteActivityContainer(android.app.IActivityContainer)> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: boolean dumpHeap(java.lang.String,int,boolean,java.lang.String,android.os.ParcelFileDescriptor)> -> _SOURCE_
android.permission.SET_ACTIVITY_WATCHER
<com.android.server.am.ActivityManagerService: void finishHeavyWeightApp()> -> _SOURCE_
android.permission.FORCE_STOP_PACKAGES
<com.android.server.am.ActivityManagerService: void forceStopPackage(java.lang.String,int)> -> _SOURCE_
android.permission.FORCE_STOP_PACKAGES
<com.android.server.am.ActivityManagerService: java.util.List getAllStackInfos()> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: android.os.Bundle getAssistContextExtras(int)> -> _SOURCE_
android.permission.GET_TOP_ACTIVITY_INFO
<com.android.server.am.ActivityManagerService: android.app.IActivityManager$ContentProviderHolder getContentProviderExternal(java.lang.String,int,android.os.IBinder)> -> _SOURCE_
android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY
<com.android.server.am.ActivityManagerService: android.content.pm.UserInfo getCurrentUser()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS
<com.android.server.am.ActivityManagerService: int getPackageProcessState(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.PACKAGE_USAGE_STATS
<com.android.server.am.ActivityManagerService: java.util.List getRecentTasks(int,int,int)> -> _SOURCE_
android.permission.GET_DETAILED_TASKS, android.permission.GET_TASKS, android.permission.REAL_GET_TASKS
<com.android.server.am.ActivityManagerService: java.util.List getRunningAppProcesses()> -> _SOURCE_
android.permission.GET_TASKS, android.permission.REAL_GET_TASKS
<com.android.server.am.ActivityManagerService: java.util.List getRunningExternalApplications()> -> _SOURCE_
android.permission.GET_TASKS, android.permission.REAL_GET_TASKS
<com.android.server.am.ActivityManagerService: I[] getRunningUserIds()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS
<com.android.server.am.ActivityManagerService: android.app.ActivityManager$StackInfo getStackInfo(int)> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: android.app.ActivityManager$TaskThumbnail getTaskThumbnail(int)> -> _SOURCE_
android.permission.READ_FRAME_BUFFER
<com.android.server.am.ActivityManagerService: java.util.List getTasks(int,int)> -> _SOURCE_
android.permission.GET_TASKS, android.permission.REAL_GET_TASKS
<com.android.server.am.ActivityManagerService: void hang(android.os.IBinder,boolean)> -> _SOURCE_
android.permission.SET_ACTIVITY_WATCHER
<com.android.server.am.ActivityManagerService: long inputDispatchingTimedOut(int,boolean,java.lang.String)> -> _SOURCE_
android.permission.FILTER_EVENTS
<com.android.server.am.ActivityManagerService: boolean isInHomeStack(int)> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: boolean isUserRunning(int,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS
<com.android.server.am.ActivityManagerService: void killAllBackgroundProcesses()> -> _SOURCE_
android.permission.KILL_BACKGROUND_PROCESSES
<com.android.server.am.ActivityManagerService: void killBackgroundProcesses(java.lang.String,int)> -> _SOURCE_
android.permission.KILL_BACKGROUND_PROCESSES
<com.android.server.am.ActivityManagerService: void killUid(int,int,java.lang.String)> -> _SOURCE_
android.permission.KILL_UID
<com.android.server.am.ActivityManagerService: boolean launchAssistIntent(android.content.Intent,int,java.lang.String,int,android.os.Bundle)> -> _SOURCE_
android.permission.GET_TOP_ACTIVITY_INFO
<com.android.server.am.ActivityManagerService: void moveTaskBackwards(int)> -> _SOURCE_
android.permission.REORDER_TASKS
<com.android.server.am.ActivityManagerService: void moveTaskToFront(int,int,android.os.Bundle)> -> _SOURCE_
android.permission.REORDER_TASKS
<com.android.server.am.ActivityManagerService: void moveTaskToStack(int,int,boolean)> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: boolean navigateUpTo(android.os.IBinder,android.content.Intent,int,android.content.Intent)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.START_ANY_ACTIVITY
<com.android.server.am.ActivityManagerService: void performIdleMaintenance()> -> _SOURCE_
android.permission.SET_ACTIVITY_WATCHER
<com.android.server.am.ActivityManagerService: boolean profileControl(java.lang.String,int,boolean,android.app.ProfilerInfo,int)> -> _SOURCE_
android.permission.SET_ACTIVITY_WATCHER
<com.android.server.am.ActivityManagerService: void registerProcessObserver(android.app.IProcessObserver)> -> _SOURCE_
android.permission.SET_ACTIVITY_WATCHER
<com.android.server.am.ActivityManagerService: void registerUidObserver(android.app.IUidObserver)> -> _SOURCE_
android.permission.SET_ACTIVITY_WATCHER
<com.android.server.am.ActivityManagerService: void registerUserSwitchObserver(android.app.IUserSwitchObserver)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.am.ActivityManagerService: void removeContentProviderExternal(java.lang.String,android.os.IBinder)> -> _SOURCE_
android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY
<com.android.server.am.ActivityManagerService: boolean removeTask(int)> -> _SOURCE_
android.permission.REMOVE_TASKS
<com.android.server.am.ActivityManagerService: boolean requestAssistContextExtras(int,com.android.internal.os.IResultReceiver,android.os.IBinder)> -> _SOURCE_
android.permission.GET_TOP_ACTIVITY_INFO
<com.android.server.am.ActivityManagerService: void requestBugReport()> -> _SOURCE_
android.permission.DUMP
<com.android.server.am.ActivityManagerService: void resizeStack(int,android.graphics.Rect)> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: void resizeTask(int,android.graphics.Rect)> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: void restart()> -> _SOURCE_
android.permission.SET_ACTIVITY_WATCHER
<com.android.server.am.ActivityManagerService: void resumeAppSwitches()> -> _SOURCE_
android.permission.STOP_APP_SWITCHES
<com.android.server.am.ActivityManagerService: void setActivityController(android.app.IActivityController)> -> _SOURCE_
android.permission.SET_ACTIVITY_WATCHER
<com.android.server.am.ActivityManagerService: void setAlwaysFinish(boolean)> -> _SOURCE_
android.permission.SET_ALWAYS_FINISH
<com.android.server.am.ActivityManagerService: void setDebugApp(java.lang.String,boolean,boolean)> -> _SOURCE_
android.permission.SET_DEBUG_APP
<com.android.server.am.ActivityManagerService: void setDumpHeapDebugLimit(java.lang.String,int,long,java.lang.String)> -> _SOURCE_
android.permission.SET_DEBUG_APP
<com.android.server.am.ActivityManagerService: void setFrontActivityScreenCompatMode(int)> -> _SOURCE_
android.permission.SET_SCREEN_COMPATIBILITY
<com.android.server.am.ActivityManagerService: void setLockScreenShown(boolean)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.am.ActivityManagerService: void setPackageAskScreenCompat(java.lang.String,boolean)> -> _SOURCE_
android.permission.SET_SCREEN_COMPATIBILITY
<com.android.server.am.ActivityManagerService: void setPackageScreenCompatMode(java.lang.String,int)> -> _SOURCE_
android.permission.SET_SCREEN_COMPATIBILITY
<com.android.server.am.ActivityManagerService: void setProcessForeground(android.os.IBinder,int,boolean)> -> _SOURCE_
android.permission.SET_PROCESS_LIMIT
<com.android.server.am.ActivityManagerService: void setProcessLimit(int)> -> _SOURCE_
android.permission.BROADCAST_STICKY, android.permission.SET_PROCESS_LIMIT
<com.android.server.am.ActivityManagerService: boolean shutdown(int)> -> _SOURCE_
android.permission.SHUTDOWN
<com.android.server.am.ActivityManagerService: void signalPersistentProcesses(int)> -> _SOURCE_
android.permission.SIGNAL_PERSISTENT_PROCESSES
<com.android.server.am.ActivityManagerService: int startActivities(android.app.IApplicationThread,java.lang.String,[android.content.Intent,[java.lang.String,android.os.IBinder,android.os.Bundle,int)> -> _SOURCE_
android.permission.SET_DEBUG_APP
<com.android.server.am.ActivityManagerService: int startActivity(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle)> -> _SOURCE_
android.permission.SET_DEBUG_APP
<com.android.server.am.ActivityManagerService: android.app.IActivityManager$WaitResult startActivityAndWait(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)> -> _SOURCE_
android.permission.SET_DEBUG_APP
<com.android.server.am.ActivityManagerService: int startActivityAsCaller(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,boolean,int)> -> _SOURCE_
android.permission.SET_DEBUG_APP
<com.android.server.am.ActivityManagerService: int startActivityAsUser(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)> -> _SOURCE_
android.permission.SET_DEBUG_APP
<com.android.server.am.ActivityManagerService: int startActivityFromRecents(int,android.os.Bundle)> -> _SOURCE_
android.permission.START_TASKS_FROM_RECENTS
<com.android.server.am.ActivityManagerService: int startActivityWithConfig(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.content.res.Configuration,android.os.Bundle,int)> -> _SOURCE_
android.permission.SET_DEBUG_APP
<com.android.server.am.ActivityManagerService: void startLockTaskModeOnCurrent()> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: boolean startUserInBackground(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.am.ActivityManagerService: int startVoiceActivity(java.lang.String,int,int,android.content.Intent,java.lang.String,android.service.voice.IVoiceInteractionSession,com.android.internal.app.IVoiceInteractor,int,android.app.ProfilerInfo,android.os.Bundle,int)> -> _SOURCE_
android.permission.BIND_VOICE_INTERACTION
<com.android.server.am.ActivityManagerService: void stopAppSwitches()> -> _SOURCE_
android.permission.STOP_APP_SWITCHES
<com.android.server.am.ActivityManagerService: void stopLockTaskModeOnCurrent()> -> _SOURCE_
android.permission.MANAGE_ACTIVITY_STACKS
<com.android.server.am.ActivityManagerService: int stopUser(int,android.app.IStopUserCallback)> -> _SOURCE_
android.permission.BROADCAST_STICKY, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.am.ActivityManagerService: void unbroadcastIntent(android.app.IApplicationThread,android.content.Intent,int)> -> _SOURCE_
android.permission.BROADCAST_STICKY
<com.android.server.am.ActivityManagerService: void unhandledBack()> -> _SOURCE_
android.permission.FORCE_BACK
<com.android.server.am.ActivityManagerService: void updateConfiguration(android.content.res.Configuration)> -> _SOURCE_
android.permission.CHANGE_CONFIGURATION
<com.android.server.am.ActivityManagerService: void updatePersistentConfiguration(android.content.res.Configuration)> -> _SOURCE_
android.permission.CHANGE_CONFIGURATION
<com.android.server.am.BatteryStatsService: long getAwakeTimeBattery()> -> _SOURCE_
android.permission.BATTERY_STATS
<com.android.server.am.BatteryStatsService: long getAwakeTimePlugged()> -> _SOURCE_
android.permission.BATTERY_STATS
<com.android.server.am.BatteryStatsService: B[] getStatistics()> -> _SOURCE_
android.permission.BATTERY_STATS
<com.android.server.am.BatteryStatsService: android.os.ParcelFileDescriptor getStatisticsStream()> -> _SOURCE_
android.permission.BATTERY_STATS
<com.android.server.am.BatteryStatsService: void noteChangeWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int,android.os.WorkSource,int,java.lang.String,java.lang.String,int,boolean)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteConnectivityChanged(int,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteDeviceIdleMode(boolean,java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteEvent(int,java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteFlashlightOff(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteFlashlightOn(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteFullWifiLockAcquired(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteFullWifiLockAcquiredFromSource(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteFullWifiLockReleased(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteFullWifiLockReleasedFromSource(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteInteractive(boolean)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteJobFinish(java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteJobStart(java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteMobileRadioPowerState(int,long)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteNetworkInterfaceType(java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteNetworkStatsEnabled()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void notePhoneDataConnectionState(int,boolean)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void notePhoneOff()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void notePhoneOn()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void notePhoneSignalStrength(android.telephony.SignalStrength)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void notePhoneState(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteResetAudio()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteResetCamera()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteResetFlashlight()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteResetVideo()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteScreenBrightness(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteScreenState(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStartAudio(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStartCamera(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStartGps(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStartSensor(int,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStartVideo(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStartWakelock(int,int,java.lang.String,java.lang.String,int,boolean)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStartWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int,boolean)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStopAudio(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStopCamera(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStopGps(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStopSensor(int,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStopVideo(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStopWakelock(int,int,java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteStopWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteSyncFinish(java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteSyncStart(java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteUserActivity(int,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteVibratorOff(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteVibratorOn(int,long)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWakeUp(java.lang.String,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiBatchedScanStartedFromSource(android.os.WorkSource,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiBatchedScanStoppedFromSource(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiMulticastDisabled(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiMulticastDisabledFromSource(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiMulticastEnabled(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiMulticastEnabledFromSource(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiOff()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiOn()> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiRadioPowerState(int,long)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiRssiChanged(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiRunning(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiRunningChanged(android.os.WorkSource,android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiScanStarted(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiScanStartedFromSource(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiScanStopped(int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiScanStoppedFromSource(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiState(int,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiStopped(android.os.WorkSource)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void noteWifiSupplicantStateChanged(int,boolean)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.BatteryStatsService: void setBatteryState(int,int,int,int,int,int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS
<com.android.server.am.ProcessStatsService: B[] getCurrentStats(java.util.List)> -> _SOURCE_
android.permission.PACKAGE_USAGE_STATS
<com.android.server.am.ProcessStatsService: android.os.ParcelFileDescriptor getStatsOverTime(long)> -> _SOURCE_
android.permission.PACKAGE_USAGE_STATS
<com.android.server.audio.AudioService: void disableSafeMediaVolume(java.lang.String)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.audio.AudioService: void forceRemoteSubmixFullVolume(boolean,android.os.IBinder)> -> _SOURCE_
android.permission.CAPTURE_AUDIO_OUTPUT
<com.android.server.audio.AudioService: void notifyVolumeControllerVisible(android.media.IVolumeController,boolean)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.audio.AudioService: java.lang.String registerAudioPolicy(android.media.audiopolicy.AudioPolicyConfig,android.media.audiopolicy.IAudioPolicyCallback,boolean)> -> _SOURCE_
android.permission.MODIFY_AUDIO_ROUTING
<com.android.server.audio.AudioService: boolean registerRemoteControlDisplay(android.media.IRemoteControlDisplay,int,int)> -> _SOURCE_
android.permission.MEDIA_CONTENT_CONTROL
<com.android.server.audio.AudioService: boolean registerRemoteController(android.media.IRemoteControlDisplay,int,int,android.content.ComponentName)> -> _SOURCE_
android.permission.MEDIA_CONTENT_CONTROL
<com.android.server.audio.AudioService: int requestAudioFocus(android.media.AudioAttributes,int,android.os.IBinder,android.media.IAudioFocusDispatcher,java.lang.String,java.lang.String,int,android.media.audiopolicy.IAudioPolicyCallback)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.audio.AudioService: void setBluetoothScoOn(boolean)> -> _SOURCE_
android.permission.MODIFY_AUDIO_SETTINGS
<com.android.server.audio.AudioService: int setFocusPropertiesForPolicy(int,android.media.audiopolicy.IAudioPolicyCallback)> -> _SOURCE_
android.permission.MODIFY_AUDIO_ROUTING
<com.android.server.audio.AudioService: void setMasterMute(boolean,int,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.audio.AudioService: void setMicrophoneMute(boolean,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MODIFY_AUDIO_SETTINGS
<com.android.server.audio.AudioService: void setMode(int,android.os.IBinder,java.lang.String)> -> _SOURCE_
android.permission.MODIFY_AUDIO_SETTINGS, android.permission.MODIFY_PHONE_STATE
<com.android.server.audio.AudioService: void setRemoteStreamVolume(int)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.audio.AudioService: void setRingerModeInternal(int,java.lang.String)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.audio.AudioService: void setRingtonePlayer(android.media.IRingtonePlayer)> -> _SOURCE_
android.permission.REMOTE_AUDIO_PLAYBACK
<com.android.server.audio.AudioService: void setSpeakerphoneOn(boolean)> -> _SOURCE_
android.permission.MODIFY_AUDIO_SETTINGS
<com.android.server.audio.AudioService: void setVolumeController(android.media.IVolumeController)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.audio.AudioService: void setVolumePolicy(android.media.VolumePolicy)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.audio.AudioService: void startBluetoothSco(android.os.IBinder,int)> -> _SOURCE_
android.permission.MODIFY_AUDIO_SETTINGS
<com.android.server.audio.AudioService: void startBluetoothScoVirtualCall(android.os.IBinder)> -> _SOURCE_
android.permission.MODIFY_AUDIO_SETTINGS
<com.android.server.audio.AudioService: void stopBluetoothSco(android.os.IBinder)> -> _SOURCE_
android.permission.MODIFY_AUDIO_SETTINGS
<com.android.server.connectivity.Tethering: void interfaceAdded(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.connectivity.Tethering: void interfaceLinkStateChanged(java.lang.String,boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.connectivity.Tethering: void interfaceStatusChanged(java.lang.String,boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.content.ContentService: void addPeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle,long)> -> _SOURCE_
android.permission.WRITE_SYNC_SETTINGS
<com.android.server.content.ContentService: void cancelSync(android.accounts.Account,java.lang.String,android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.content.ContentService: void cancelSyncAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.content.ContentService: java.util.List getCurrentSyncs()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_STATS
<com.android.server.content.ContentService: java.util.List getCurrentSyncsAsUser(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_STATS
<com.android.server.content.ContentService: int getIsSyncable(android.accounts.Account,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_SETTINGS
<com.android.server.content.ContentService: int getIsSyncableAsUser(android.accounts.Account,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_SETTINGS
<com.android.server.content.ContentService: boolean getMasterSyncAutomatically()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_SETTINGS
<com.android.server.content.ContentService: boolean getMasterSyncAutomaticallyAsUser(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_SETTINGS
<com.android.server.content.ContentService: java.util.List getPeriodicSyncs(android.accounts.Account,java.lang.String,android.content.ComponentName)> -> _SOURCE_
android.permission.READ_SYNC_SETTINGS
<com.android.server.content.ContentService: java.lang.String[] getSyncAdapterPackagesForAuthorityAsUser(java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.content.ContentService: android.content.SyncAdapterType[] getSyncAdapterTypes()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.content.ContentService: android.content.SyncAdapterType[] getSyncAdapterTypesAsUser(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.content.ContentService: boolean getSyncAutomatically(android.accounts.Account,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_SETTINGS
<com.android.server.content.ContentService: boolean getSyncAutomaticallyAsUser(android.accounts.Account,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_SETTINGS
<com.android.server.content.ContentService: android.content.SyncStatusInfo getSyncStatus(android.accounts.Account,java.lang.String,android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_STATS
<com.android.server.content.ContentService: android.content.SyncStatusInfo getSyncStatusAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_STATS
<com.android.server.content.ContentService: boolean isSyncActive(android.accounts.Account,java.lang.String,android.content.ComponentName)> -> _SOURCE_
android.permission.READ_SYNC_STATS
<com.android.server.content.ContentService: boolean isSyncPending(android.accounts.Account,java.lang.String,android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_STATS
<com.android.server.content.ContentService: boolean isSyncPendingAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.READ_SYNC_STATS
<com.android.server.content.ContentService: void registerContentObserver(android.net.Uri,boolean,android.database.IContentObserver,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.content.ContentService: void removePeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle)> -> _SOURCE_
android.permission.WRITE_SYNC_SETTINGS
<com.android.server.content.ContentService: void setIsSyncable(android.accounts.Account,java.lang.String,int)> -> _SOURCE_
android.permission.WRITE_SYNC_SETTINGS
<com.android.server.content.ContentService: void setMasterSyncAutomatically(boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SYNC_SETTINGS
<com.android.server.content.ContentService: void setMasterSyncAutomaticallyAsUser(boolean,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SYNC_SETTINGS
<com.android.server.content.ContentService: void setSyncAutomatically(android.accounts.Account,java.lang.String,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SYNC_SETTINGS
<com.android.server.content.ContentService: void setSyncAutomaticallyAsUser(android.accounts.Account,java.lang.String,boolean,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.WRITE_SYNC_SETTINGS
<com.android.server.content.ContentService: void sync(android.content.SyncRequest)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.content.ContentService: void syncAsUser(android.content.SyncRequest,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void addCrossProfileIntentFilter(android.content.ComponentName,android.content.IntentFilter,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean addCrossProfileWidgetProvider(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void addPersistentPreferredActivity(android.content.ComponentName,android.content.IntentFilter,android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void choosePrivateKeyAlias(int,android.net.Uri,java.lang.String,android.os.IBinder)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void clearCrossProfileIntentFilters(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void clearDeviceInitializer(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void clearDeviceOwner(java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void clearPackagePersistentPreferredActivities(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void clearProfileOwner(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: android.os.UserHandle createAndInitializeUser(android.content.ComponentName,java.lang.String,java.lang.String,android.content.ComponentName,android.os.Bundle)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_DEVICE_ADMINS, android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS
<com.android.server.devicepolicy.DevicePolicyManagerService: android.os.UserHandle createUser(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void enableSystemApp(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int enableSystemAppWithIntent(android.content.ComponentName,android.content.Intent)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void enforceCanManageCaCerts(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_CA_CERTIFICATES
<com.android.server.devicepolicy.DevicePolicyManagerService: java.lang.String[] getAccountTypesWithManagementDisabled()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.lang.String[] getAccountTypesWithManagementDisabledAsUser(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.util.List getActiveAdmins(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: android.os.Bundle getApplicationRestrictions(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getAutoTimeRequired()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getBluetoothContactSharingDisabled(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getBluetoothContactSharingDisabledForUser(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getCameraDisabled(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.lang.String getCertInstallerPackage(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getCrossProfileCallerIdDisabled(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getCrossProfileCallerIdDisabledForUser(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.util.List getCrossProfileWidgetProviders(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getCurrentFailedPasswordAttempts(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.lang.String getDeviceOwnerName()> -> _SOURCE_
android.permission.MANAGE_USERS
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getDoNotAskCredentialsOnBoot()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.QUERY_DO_NOT_ASK_CREDENTIALS_ON_BOOT
<com.android.server.devicepolicy.DevicePolicyManagerService: android.content.ComponentName getGlobalProxyAdmin(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getKeyguardDisabledFeatures(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.lang.String[] getLockTaskPackages(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getMaximumFailedPasswordsForWipe(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: long getMaximumTimeToLock(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: long getPasswordExpiration(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: long getPasswordExpirationTimeout(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordHistoryLength(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordMinimumLength(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordMinimumLetters(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordMinimumLowerCase(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordMinimumNonLetter(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordMinimumNumeric(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordMinimumSymbols(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordMinimumUpperCase(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPasswordQuality(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPermissionGrantState(android.content.ComponentName,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getPermissionPolicy(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.util.List getPermittedAccessibilityServices(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.util.List getPermittedInputMethods(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.lang.String getProfileOwnerName(int)> -> _SOURCE_
android.permission.MANAGE_USERS
<com.android.server.devicepolicy.DevicePolicyManagerService: int getProfileWithMinimumFailedPasswordsForWipe(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void getRemoveWarning(android.content.ComponentName,android.os.RemoteCallback,int)> -> _SOURCE_
android.permission.BIND_DEVICE_ADMIN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: android.content.ComponentName getRestrictionsProvider(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getScreenCaptureDisabled(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean getStorageEncryption(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int getStorageEncryptionStatus(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: java.util.List getTrustAgentConfiguration(android.content.ComponentName,android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean hasGrantedPolicy(android.content.ComponentName,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean hasUserSetupCompleted()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean installCaCert(android.content.ComponentName,[byte)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_CA_CERTIFICATES
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean installKeyPair(android.content.ComponentName,[byte,[byte,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean isActivePasswordSufficient(int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean isAdminActive(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean isApplicationHidden(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean isLockTaskPermitted(java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean isMasterVolumeMuted(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean isRemovingAdmin(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean isUninstallBlocked(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void lockNow()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void notifyLockTaskModeChanged(boolean,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void notifyPendingSystemUpdate(long)> -> _SOURCE_
android.permission.NOTIFY_PENDING_SYSTEM_UPDATE
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean packageHasActiveAdmins(java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void removeActiveAdmin(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_DEVICE_ADMINS
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean removeCrossProfileWidgetProvider(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean removeUser(android.content.ComponentName,android.os.UserHandle)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void reportFailedPasswordAttempt(int)> -> _SOURCE_
android.permission.BIND_DEVICE_ADMIN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void reportSuccessfulPasswordAttempt(int)> -> _SOURCE_
android.permission.BIND_DEVICE_ADMIN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean resetPassword(java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setAccountManagementDisabled(android.content.ComponentName,java.lang.String,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setActiveAdmin(android.content.ComponentName,boolean,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_DEVICE_ADMINS
<com.android.server.devicepolicy.DevicePolicyManagerService: void setActivePasswordState(int,int,int,int,int,int,int,int,int)> -> _SOURCE_
android.permission.BIND_DEVICE_ADMIN, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setApplicationHidden(android.content.ComponentName,java.lang.String,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setApplicationRestrictions(android.content.ComponentName,java.lang.String,android.os.Bundle)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setAutoTimeRequired(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setBluetoothContactSharingDisabled(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setCameraDisabled(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setCertInstallerPackage(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setCrossProfileCallerIdDisabled(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setDeviceInitializer(android.content.ComponentName,android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_DEVICE_ADMINS
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setDeviceOwner(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS
<com.android.server.devicepolicy.DevicePolicyManagerService: android.content.ComponentName setGlobalProxy(android.content.ComponentName,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setGlobalSetting(android.content.ComponentName,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setKeyguardDisabled(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setKeyguardDisabledFeatures(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setLockTaskPackages(android.content.ComponentName,[java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setMasterVolumeMuted(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setMaximumFailedPasswordsForWipe(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setMaximumTimeToLock(android.content.ComponentName,long)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordExpirationTimeout(android.content.ComponentName,long)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordHistoryLength(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordMinimumLength(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordMinimumLetters(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordMinimumLowerCase(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordMinimumNonLetter(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordMinimumNumeric(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordMinimumSymbols(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordMinimumUpperCase(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPasswordQuality(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setPermissionGrantState(android.content.ComponentName,java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS
<com.android.server.devicepolicy.DevicePolicyManagerService: void setPermissionPolicy(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setPermittedAccessibilityServices(android.content.ComponentName,java.util.List)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setPermittedInputMethods(android.content.ComponentName,java.util.List)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setProfileEnabled(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setProfileName(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setProfileOwner(android.content.ComponentName,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS
<com.android.server.devicepolicy.DevicePolicyManagerService: void setRecommendedGlobalProxy(android.content.ComponentName,android.net.ProxyInfo)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setRestrictionsProvider(android.content.ComponentName,android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setScreenCaptureDisabled(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setSecureSetting(android.content.ComponentName,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setStatusBarDisabled(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: int setStorageEncryption(android.content.ComponentName,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setSystemUpdatePolicy(android.content.ComponentName,android.app.admin.SystemUpdatePolicy)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setTrustAgentConfiguration(android.content.ComponentName,android.content.ComponentName,android.os.PersistableBundle)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setUninstallBlocked(android.content.ComponentName,java.lang.String,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean setUserEnabled(android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_DEVICE_ADMINS
<com.android.server.devicepolicy.DevicePolicyManagerService: void setUserIcon(android.content.ComponentName,android.graphics.Bitmap)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void setUserRestriction(android.content.ComponentName,java.lang.String,boolean)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: boolean switchUser(android.content.ComponentName,android.os.UserHandle)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.devicepolicy.DevicePolicyManagerService: void uninstallCaCerts(android.content.ComponentName,[java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_CA_CERTIFICATES
<com.android.server.devicepolicy.DevicePolicyManagerService: void wipeData(int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.display.DisplayManagerService.BinderService: void connectWifiDisplay(java.lang.String)> -> _SOURCE_
android.permission.CONFIGURE_WIFI_DISPLAY
<com.android.server.display.DisplayManagerService.BinderService: int createVirtualDisplay(android.hardware.display.IVirtualDisplayCallback,android.media.projection.IMediaProjection,java.lang.String,java.lang.String,int,int,int,android.view.Surface,int)> -> _SOURCE_
android.permission.CAPTURE_SECURE_VIDEO_OUTPUT, android.permission.CAPTURE_VIDEO_OUTPUT
<com.android.server.display.DisplayManagerService.BinderService: void forgetWifiDisplay(java.lang.String)> -> _SOURCE_
android.permission.CONFIGURE_WIFI_DISPLAY
<com.android.server.display.DisplayManagerService.BinderService: void pauseWifiDisplay()> -> _SOURCE_
android.permission.CONFIGURE_WIFI_DISPLAY
<com.android.server.display.DisplayManagerService.BinderService: void renameWifiDisplay(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.CONFIGURE_WIFI_DISPLAY
<com.android.server.display.DisplayManagerService.BinderService: void requestColorTransform(int,int)> -> _SOURCE_
android.permission.CONFIGURE_DISPLAY_COLOR_TRANSFORM
<com.android.server.display.DisplayManagerService.BinderService: void resumeWifiDisplay()> -> _SOURCE_
android.permission.CONFIGURE_WIFI_DISPLAY
<com.android.server.display.DisplayManagerService.BinderService: void startWifiDisplayScan()> -> _SOURCE_
android.permission.CONFIGURE_WIFI_DISPLAY
<com.android.server.display.DisplayManagerService.BinderService: void stopWifiDisplayScan()> -> _SOURCE_
android.permission.CONFIGURE_WIFI_DISPLAY
<com.android.server.dreams.DreamManagerService.BinderService: void awaken()> -> _SOURCE_
android.permission.WRITE_DREAM_STATE
<com.android.server.dreams.DreamManagerService.BinderService: void dream()> -> _SOURCE_
android.permission.WRITE_DREAM_STATE
<com.android.server.dreams.DreamManagerService.BinderService: android.content.ComponentName getDefaultDreamComponent()> -> _SOURCE_
android.permission.READ_DREAM_STATE
<com.android.server.dreams.DreamManagerService.BinderService: android.content.ComponentName[] getDreamComponents()> -> _SOURCE_
android.permission.READ_DREAM_STATE
<com.android.server.dreams.DreamManagerService.BinderService: boolean isDreaming()> -> _SOURCE_
android.permission.READ_DREAM_STATE
<com.android.server.dreams.DreamManagerService.BinderService: void setDreamComponents([android.content.ComponentName)> -> _SOURCE_
android.permission.WRITE_DREAM_STATE
<com.android.server.dreams.DreamManagerService.BinderService: void testDream(android.content.ComponentName)> -> _SOURCE_
android.permission.WRITE_DREAM_STATE
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: void authenticate(android.os.IBinder,long,int,android.hardware.fingerprint.IFingerprintServiceReceiver,int,java.lang.String)> -> _SOURCE_
android.permission.MANAGE_FINGERPRINT, android.permission.USE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: void cancelAuthentication(android.os.IBinder,java.lang.String)> -> _SOURCE_
android.permission.USE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: void cancelEnrollment(android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: void enroll(android.os.IBinder,[byte,int,android.hardware.fingerprint.IFingerprintServiceReceiver,int)> -> _SOURCE_
android.permission.MANAGE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: java.util.List getEnrolledFingerprints(int,java.lang.String)> -> _SOURCE_
android.permission.USE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: boolean hasEnrolledFingerprints(int,java.lang.String)> -> _SOURCE_
android.permission.USE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: boolean isHardwareDetected(long,java.lang.String)> -> _SOURCE_
android.permission.USE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: int postEnroll(android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: long preEnroll(android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: void remove(android.os.IBinder,int,int,android.hardware.fingerprint.IFingerprintServiceReceiver)> -> _SOURCE_
android.permission.MANAGE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: void rename(int,int,java.lang.String)> -> _SOURCE_
android.permission.MANAGE_FINGERPRINT
<com.android.server.fingerprint.FingerprintService.FingerprintServiceWrapper: void resetTimeout([byte)> -> _SOURCE_
android.permission.RESET_FINGERPRINT_LOCKOUT
<com.android.server.hdmi.HdmiControlService.BinderService: void addDeviceEventListener(android.hardware.hdmi.IHdmiDeviceEventListener)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void addHdmiMhlVendorCommandListener(android.hardware.hdmi.IHdmiMhlVendorCommandListener)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void addHotplugEventListener(android.hardware.hdmi.IHdmiHotplugEventListener)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void addSystemAudioModeChangeListener(android.hardware.hdmi.IHdmiSystemAudioModeChangeListener)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void addVendorCommandListener(android.hardware.hdmi.IHdmiVendorCommandListener,int)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: boolean canChangeSystemAudioMode()> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void clearTimerRecording(int,int,[byte)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void deviceSelect(int,android.hardware.hdmi.IHdmiControlCallback)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: android.hardware.hdmi.HdmiDeviceInfo getActiveSource()> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: java.util.List getDeviceList()> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: java.util.List getInputDevices()> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: java.util.List getPortInfo()> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: I[] getSupportedTypes()> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: boolean getSystemAudioMode()> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void oneTouchPlay(android.hardware.hdmi.IHdmiControlCallback)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void portSelect(int,android.hardware.hdmi.IHdmiControlCallback)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void queryDisplayStatus(android.hardware.hdmi.IHdmiControlCallback)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void removeHotplugEventListener(android.hardware.hdmi.IHdmiHotplugEventListener)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void removeSystemAudioModeChangeListener(android.hardware.hdmi.IHdmiSystemAudioModeChangeListener)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void sendKeyEvent(int,int,boolean)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void sendMhlVendorCommand(int,int,int,[byte)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void sendStandby(int,int)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void sendVendorCommand(int,int,[byte,boolean)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void setArcMode(boolean)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void setHdmiRecordListener(android.hardware.hdmi.IHdmiRecordListener)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void setInputChangeListener(android.hardware.hdmi.IHdmiInputChangeListener)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void setProhibitMode(boolean)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void setSystemAudioMode(boolean,android.hardware.hdmi.IHdmiControlCallback)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void setSystemAudioMute(boolean)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void setSystemAudioVolume(int,int,int)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void startOneTouchRecord(int,[byte)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void startTimerRecording(int,int,[byte)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.hdmi.HdmiControlService.BinderService: void stopOneTouchRecord(int)> -> _SOURCE_
android.permission.HDMI_CEC
<com.android.server.input.InputManagerService: void addKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)> -> _SOURCE_
android.permission.SET_KEYBOARD_LAYOUT
<com.android.server.input.InputManagerService: void registerTabletModeChangedListener(android.hardware.input.ITabletModeChangedListener)> -> _SOURCE_
android.permission.TABLET_MODE_LISTENER
<com.android.server.input.InputManagerService: void removeKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)> -> _SOURCE_
android.permission.SET_KEYBOARD_LAYOUT
<com.android.server.input.InputManagerService: void setCurrentKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)> -> _SOURCE_
android.permission.SET_KEYBOARD_LAYOUT
<com.android.server.input.InputManagerService: void setTouchCalibrationForInputDevice(java.lang.String,int,android.hardware.input.TouchCalibration)> -> _SOURCE_
android.permission.SET_INPUT_CALIBRATION
<com.android.server.input.InputManagerService: void tryPointerSpeed(int)> -> _SOURCE_
android.permission.SET_POINTER_SPEED
<com.android.server.job.JobSchedulerService.JobSchedulerStub: int schedule(android.app.job.JobInfo)> -> _SOURCE_
android.permission.RECEIVE_BOOT_COMPLETED
<com.android.server.media.MediaRouterService: void registerClientAsUser(android.media.IMediaRouterClient,java.lang.String,int)> -> _SOURCE_
android.permission.CONFIGURE_WIFI_DISPLAY
<com.android.server.media.MediaSessionRecord.SessionStub: void setFlags(int)> -> _SOURCE_
android.permission.MODIFY_PHONE_STATE
<com.android.server.media.projection.MediaProjectionManagerService.BinderService: void addCallback(android.media.projection.IMediaProjectionWatcherCallback)> -> _SOURCE_
android.permission.MANAGE_MEDIA_PROJECTION
<com.android.server.media.projection.MediaProjectionManagerService.BinderService: android.media.projection.IMediaProjection createProjection(int,java.lang.String,int,boolean)> -> _SOURCE_
android.permission.MANAGE_MEDIA_PROJECTION, android.permission.UPDATE_APP_OPS_STATS
<com.android.server.media.projection.MediaProjectionManagerService.BinderService: android.media.projection.MediaProjectionInfo getActiveProjectionInfo()> -> _SOURCE_
android.permission.MANAGE_MEDIA_PROJECTION
<com.android.server.media.projection.MediaProjectionManagerService.BinderService: void removeCallback(android.media.projection.IMediaProjectionWatcherCallback)> -> _SOURCE_
android.permission.MANAGE_MEDIA_PROJECTION
<com.android.server.media.projection.MediaProjectionManagerService.BinderService: void stopActiveProjection()> -> _SOURCE_
android.permission.MANAGE_MEDIA_PROJECTION
<com.android.server.net.NetworkPolicyManagerService: void addUidPolicy(int,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL, android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: void factoryReset(java.lang.String)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL, android.permission.MANAGE_NETWORK_POLICY, android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.server.net.NetworkPolicyManagerService: android.net.NetworkPolicy[] getNetworkPolicies(java.lang.String)> -> _SOURCE_
android.permission.MANAGE_NETWORK_POLICY, android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.server.net.NetworkPolicyManagerService: android.net.NetworkQuotaInfo getNetworkQuotaInfo(android.net.NetworkState)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.net.NetworkPolicyManagerService: boolean getRestrictBackground()> -> _SOURCE_
android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: int getUidPolicy(int)> -> _SOURCE_
android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: I[] getUidsWithPolicy(int)> -> _SOURCE_
android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: boolean isUidForeground(int)> -> _SOURCE_
android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: void registerListener(android.net.INetworkPolicyListener)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.net.NetworkPolicyManagerService: void removeUidPolicy(int,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL, android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: void setDeviceIdleMode(boolean)> -> _SOURCE_
android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: void setNetworkPolicies([android.net.NetworkPolicy)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL, android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: void setRestrictBackground(boolean)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL, android.permission.MANAGE_NETWORK_POLICY, android.permission.READ_PRIVILEGED_PHONE_STATE
<com.android.server.net.NetworkPolicyManagerService: void setUidPolicy(int,int)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL, android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: void snoozeLimit(android.net.NetworkTemplate)> -> _SOURCE_
android.permission.MANAGE_NETWORK_POLICY
<com.android.server.net.NetworkPolicyManagerService: void unregisterListener(android.net.INetworkPolicyListener)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL
<com.android.server.net.NetworkStatsService: void advisePersistThreshold(long)> -> _SOURCE_
android.permission.CONNECTIVITY_INTERNAL, android.permission.MODIFY_NETWORK_ACCOUNTING
<com.android.server.net.NetworkStatsService: void forceUpdate()> -> _SOURCE_
android.permission.READ_NETWORK_USAGE_HISTORY
<com.android.server.net.NetworkStatsService: void forceUpdateIfaces()> -> _SOURCE_
android.permission.READ_NETWORK_USAGE_HISTORY
<com.android.server.net.NetworkStatsService: android.net.NetworkStats getDataLayerSnapshotForUid(int)> -> _SOURCE_
android.permission.ACCESS_NETWORK_STATE
<com.android.server.net.NetworkStatsService: long getNetworkTotalBytes(android.net.NetworkTemplate,long,long)> -> _SOURCE_
android.permission.READ_NETWORK_USAGE_HISTORY
<com.android.server.net.NetworkStatsService: void incrementOperationCount(int,int,int)> -> _SOURCE_
android.permission.MODIFY_NETWORK_ACCOUNTING
<com.android.server.net.NetworkStatsService: void setUidForeground(int,boolean)> -> _SOURCE_
android.permission.MODIFY_NETWORK_ACCOUNTING
<com.android.server.pm.PackageInstallerService: void setPermissionsResult(int,boolean)> -> _SOURCE_
android.permission.INSTALL_PACKAGES
<com.android.server.pm.PackageInstallerService: void uninstall(java.lang.String,java.lang.String,int,android.content.IntentSender,int)> -> _SOURCE_
android.permission.DELETE_PACKAGES
<com.android.server.pm.PackageManagerService: void addCrossProfileIntentFilter(android.content.IntentFilter,java.lang.String,int,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void addOnPermissionsChangeListener(android.content.pm.IOnPermissionsChangeListener)> -> _SOURCE_
android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS
<com.android.server.pm.PackageManagerService: void addPreferredActivity(android.content.IntentFilter,int,[android.content.ComponentName,android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: boolean canForwardTo(android.content.Intent,java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void clearApplicationUserData(java.lang.String,android.content.pm.IPackageDataObserver,int)> -> _SOURCE_
android.permission.CLEAR_APP_USER_DATA, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void clearCrossProfileIntentFilters(int,java.lang.String)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void clearPackagePreferredActivities(java.lang.String)> -> _SOURCE_
android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void deleteApplicationCacheFiles(java.lang.String,android.content.pm.IPackageDataObserver)> -> _SOURCE_
android.permission.DELETE_CACHE_FILES
<com.android.server.pm.PackageManagerService: void deletePackage(java.lang.String,android.content.pm.IPackageDeleteObserver2,int,int)> -> _SOURCE_
android.permission.DELETE_PACKAGES, android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void deletePackageAsUser(java.lang.String,android.content.pm.IPackageDeleteObserver,int,int)> -> _SOURCE_
android.permission.DELETE_PACKAGES, android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void extendVerificationTimeout(int,int,long)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.PACKAGE_VERIFICATION_AGENT, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void freeStorage(java.lang.String,long,android.content.IntentSender)> -> _SOURCE_
android.permission.CLEAR_APP_CACHE
<com.android.server.pm.PackageManagerService: void freeStorageAndNotify(java.lang.String,long,android.content.pm.IPackageDataObserver)> -> _SOURCE_
android.permission.CLEAR_APP_CACHE
<com.android.server.pm.PackageManagerService: android.content.pm.ActivityInfo getActivityInfo(android.content.ComponentName,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: int getApplicationEnabledSetting(java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: boolean getApplicationHiddenSettingAsUser(java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_USERS
<com.android.server.pm.PackageManagerService: android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: int getComponentEnabledSetting(android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: android.content.ComponentName getHomeActivities(java.util.List)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: android.content.pm.ParceledListSlice getInstalledPackages(int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: android.content.pm.ResolveInfo getLastChosenActivity(android.content.Intent,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: int getMoveStatus(int)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.pm.PackageManagerService: I[] getPackageGids(java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: android.content.pm.PackageInfo getPackageInfo(java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void getPackageSizeInfo(java.lang.String,int,android.content.pm.IPackageStatsObserver)> -> _SOURCE_
android.permission.GET_PACKAGE_SIZE, android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: int getPackageUid(java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: int getPermissionFlags(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS
<com.android.server.pm.PackageManagerService: android.content.pm.ProviderInfo getProviderInfo(android.content.ComponentName,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: android.content.pm.ActivityInfo getReceiverInfo(android.content.ComponentName,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: android.content.pm.ServiceInfo getServiceInfo(android.content.ComponentName,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: android.content.pm.VerifierDeviceIdentity getVerifierDeviceIdentity()> -> _SOURCE_
android.permission.PACKAGE_VERIFICATION_AGENT
<com.android.server.pm.PackageManagerService: void grantRuntimePermission(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: int installExistingPackageAsUser(java.lang.String,int)> -> _SOURCE_
android.permission.INSTALL_PACKAGES, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void installPackage(java.lang.String,android.content.pm.IPackageInstallObserver2,int,java.lang.String,android.content.pm.VerificationParams,java.lang.String)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS, android.permission.INSTALL_PACKAGES, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void installPackageAsUser(java.lang.String,android.content.pm.IPackageInstallObserver2,int,java.lang.String,android.content.pm.VerificationParams,java.lang.String,int)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS, android.permission.INSTALL_PACKAGES, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: boolean isPackageAvailable(java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: boolean isPermissionRevokedByPolicy(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: int movePackage(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MOVE_PACKAGE, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: int movePrimaryStorage(java.lang.String)> -> _SOURCE_
android.permission.MOVE_PACKAGE
<com.android.server.pm.PackageManagerService: java.util.List queryIntentActivities(android.content.Intent,java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: java.util.List queryIntentActivityOptions(android.content.ComponentName,[android.content.Intent,[java.lang.String,android.content.Intent,java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: java.util.List queryIntentContentProviders(android.content.Intent,java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: java.util.List queryIntentReceivers(android.content.Intent,java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: java.util.List queryIntentServices(android.content.Intent,java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void registerMoveCallback(android.content.pm.IPackageMoveObserver)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.pm.PackageManagerService: void replacePreferredActivity(android.content.IntentFilter,int,[android.content.ComponentName,android.content.ComponentName,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void resetApplicationPreferences(int)> -> _SOURCE_
android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void resetRuntimePermissions()> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS
<com.android.server.pm.PackageManagerService: android.content.pm.ResolveInfo resolveIntent(android.content.Intent,java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: android.content.pm.ResolveInfo resolveService(android.content.Intent,java.lang.String,int,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void revokeRuntimePermission(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS
<com.android.server.pm.PackageManagerService: void setApplicationEnabledSetting(java.lang.String,int,int,int,java.lang.String)> -> _SOURCE_
android.permission.CHANGE_COMPONENT_ENABLED_STATE, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: boolean setApplicationHiddenSettingAsUser(java.lang.String,boolean,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.MANAGE_USERS
<com.android.server.pm.PackageManagerService: boolean setBlockUninstallForUser(java.lang.String,boolean,int)> -> _SOURCE_
android.permission.DELETE_PACKAGES
<com.android.server.pm.PackageManagerService: void setComponentEnabledSetting(android.content.ComponentName,int,int,int)> -> _SOURCE_
android.permission.CHANGE_COMPONENT_ENABLED_STATE, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: boolean setDefaultBrowserPackageName(java.lang.String,int)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: boolean setInstallLocation(int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.pm.PackageManagerService: void setLastChosenActivity(android.content.Intent,java.lang.String,int,android.content.IntentFilter,int,android.content.ComponentName)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void setPackageStoppedState(java.lang.String,boolean,int)> -> _SOURCE_
android.permission.CHANGE_COMPONENT_ENABLED_STATE, android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void setPermissionEnforced(java.lang.String,boolean)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS
<com.android.server.pm.PackageManagerService: boolean shouldShowRequestPermissionRationale(java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.INTERACT_ACROSS_USERS_FULL
<com.android.server.pm.PackageManagerService: void systemReady()> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void unregisterMoveCallback(android.content.pm.IPackageMoveObserver)> -> _SOURCE_
android.permission.MOUNT_UNMOUNT_FILESYSTEMS
<com.android.server.pm.PackageManagerService: void updateExternalMediaStatus(boolean,boolean)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: boolean updateIntentVerificationStatus(java.lang.String,int,int)> -> _SOURCE_
android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.pm.PackageManagerService: void updatePermissionFlags(java.lang.String,java.lang.String,int,int,int)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS
<com.android.server.pm.PackageManagerService: void updatePermissionFlagsForAllApps(int,int,int)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.REVOKE_RUNTIME_PERMISSIONS
<com.android.server.pm.PackageManagerService: void verifyIntentFilter(int,int,java.util.List)> -> _SOURCE_
android.permission.INTENT_FILTER_VERIFICATION_AGENT
<com.android.server.pm.PackageManagerService: void verifyPendingInstall(int,int)> -> _SOURCE_
android.permission.GRANT_RUNTIME_PERMISSIONS, android.permission.INTERACT_ACROSS_USERS_FULL, android.permission.PACKAGE_VERIFICATION_AGENT, android.permission.REVOKE_RUNTIME_PERMISSIONS, android.permission.SET_PREFERRED_APPLICATIONS
<com.android.server.power.PowerManagerService.BinderService: void acquireWakeLock(android.os.IBinder,int,java.lang.String,java.lang.String,android.os.WorkSource,java.lang.String)> -> _SOURCE_
android.permission.WAKE_LOCK
<com.android.server.power.PowerManagerService.BinderService: void acquireWakeLockWithUid(android.os.IBinder,int,java.lang.String,java.lang.String,int)> -> _SOURCE_
android.permission.WAKE_LOCK
<com.android.server.power.PowerManagerService.BinderService: void boostScreenBrightness(long)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: void crash(java.lang.String)> -> _SOURCE_
android.permission.REBOOT
<com.android.server.power.PowerManagerService.BinderService: void goToSleep(long,int,int)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: void nap(long)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: void powerHint(int,int)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: void reboot(boolean,java.lang.String,boolean)> -> _SOURCE_
android.permission.REBOOT, android.permission.RECOVERY
<com.android.server.power.PowerManagerService.BinderService: void releaseWakeLock(android.os.IBinder,int)> -> _SOURCE_
android.permission.WAKE_LOCK
<com.android.server.power.PowerManagerService.BinderService: void setAttentionLight(boolean,int)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: boolean setPowerSaveMode(boolean)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: void setTemporaryScreenAutoBrightnessAdjustmentSettingOverride(float)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: void setTemporaryScreenBrightnessSettingOverride(int)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: void shutdown(boolean,boolean)> -> _SOURCE_
android.permission.REBOOT
<com.android.server.power.PowerManagerService.BinderService: void updateWakeLockUids(android.os.IBinder,[int)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS, android.permission.WAKE_LOCK
<com.android.server.power.PowerManagerService.BinderService: void updateWakeLockWorkSource(android.os.IBinder,android.os.WorkSource,java.lang.String)> -> _SOURCE_
android.permission.UPDATE_DEVICE_STATS, android.permission.WAKE_LOCK
<com.android.server.power.PowerManagerService.BinderService: void userActivity(long,int,int)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.power.PowerManagerService.BinderService: void wakeUp(long,java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.sip.SipService: void close(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.sip.SipService: android.net.sip.ISipSession createSession(android.net.sip.SipProfile,android.net.sip.ISipSessionListener,java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.sip.SipService: android.net.sip.SipProfile[] getListOfProfiles(java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.sip.SipService: android.net.sip.ISipSession getPendingSession(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.sip.SipService: boolean isOpened(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.sip.SipService: boolean isRegistered(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.sip.SipService: void open(android.net.sip.SipProfile,java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.sip.SipService: void open3(android.net.sip.SipProfile,android.app.PendingIntent,android.net.sip.ISipSessionListener,java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.sip.SipService: void setRegistrationListener(java.lang.String,android.net.sip.ISipSessionListener,java.lang.String)> -> _SOURCE_
android.permission.USE_SIP
<com.android.server.statusbar.StatusBarManagerService: void clearNotificationEffects()> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void collapsePanels()> -> _SOURCE_
android.permission.EXPAND_STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void disable(int,android.os.IBinder,java.lang.String)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void disable2(int,android.os.IBinder,java.lang.String)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void disable2ForUser(int,android.os.IBinder,java.lang.String,int)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void disableForUser(int,android.os.IBinder,java.lang.String,int)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void expandNotificationsPanel()> -> _SOURCE_
android.permission.EXPAND_STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void expandSettingsPanel()> -> _SOURCE_
android.permission.EXPAND_STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void onClearAllNotifications(int)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void onNotificationActionClick(java.lang.String,int)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void onNotificationClear(java.lang.String,java.lang.String,int,int)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void onNotificationClick(java.lang.String)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void onNotificationError(java.lang.String,java.lang.String,int,int,int,java.lang.String,int)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void onNotificationExpansionChanged(java.lang.String,boolean,boolean)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void onNotificationVisibilityChanged([com.android.internal.statusbar.NotificationVisibility,[com.android.internal.statusbar.NotificationVisibility)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void onPanelHidden()> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void onPanelRevealed(boolean,int)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void registerStatusBar(com.android.internal.statusbar.IStatusBar,com.android.internal.statusbar.StatusBarIconList,[int,java.util.List)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void removeIcon(java.lang.String)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void setIcon(java.lang.String,java.lang.String,int,int,java.lang.String)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void setIconVisibility(java.lang.String,boolean)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void setImeWindowStatus(android.os.IBinder,int,int,boolean)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.statusbar.StatusBarManagerService: void setSystemUiVisibility(int,int,java.lang.String)> -> _SOURCE_
android.permission.STATUS_BAR_SERVICE
<com.android.server.statusbar.StatusBarManagerService: void topAppWindowChanged(boolean)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.tv.TvInputManagerService.BinderService: android.media.tv.ITvInputHardware acquireTvInputHardware(int,android.media.tv.ITvInputHardwareCallback,android.media.tv.TvInputInfo,int)> -> _SOURCE_
android.permission.TV_INPUT_HARDWARE
<com.android.server.tv.TvInputManagerService.BinderService: void addBlockedRating(java.lang.String,int)> -> _SOURCE_
android.permission.MODIFY_PARENTAL_CONTROLS
<com.android.server.tv.TvInputManagerService.BinderService: boolean captureFrame(java.lang.String,android.view.Surface,android.media.tv.TvStreamConfig,int)> -> _SOURCE_
android.permission.CAPTURE_TV_INPUT
<com.android.server.tv.TvInputManagerService.BinderService: java.util.List getAvailableTvStreamConfigList(java.lang.String,int)> -> _SOURCE_
android.permission.CAPTURE_TV_INPUT
<com.android.server.tv.TvInputManagerService.BinderService: java.util.List getDvbDeviceList()> -> _SOURCE_
android.permission.DVB_DEVICE
<com.android.server.tv.TvInputManagerService.BinderService: java.util.List getHardwareList()> -> _SOURCE_
android.permission.TV_INPUT_HARDWARE
<com.android.server.tv.TvInputManagerService.BinderService: android.os.ParcelFileDescriptor openDvbDevice(android.media.tv.DvbDeviceInfo,int)> -> _SOURCE_
android.permission.DVB_DEVICE
<com.android.server.tv.TvInputManagerService.BinderService: void releaseTvInputHardware(int,android.media.tv.ITvInputHardware,int)> -> _SOURCE_
android.permission.TV_INPUT_HARDWARE
<com.android.server.tv.TvInputManagerService.BinderService: void removeBlockedRating(java.lang.String,int)> -> _SOURCE_
android.permission.MODIFY_PARENTAL_CONTROLS
<com.android.server.tv.TvInputManagerService.BinderService: void setParentalControlsEnabled(boolean,int)> -> _SOURCE_
android.permission.MODIFY_PARENTAL_CONTROLS
<com.android.server.tv.TvInputManagerService.ServiceCallback: void addHardwareTvInput(int,android.media.tv.TvInputInfo)> -> _SOURCE_
android.permission.TV_INPUT_HARDWARE
<com.android.server.tv.TvInputManagerService.ServiceCallback: void addHdmiTvInput(int,android.media.tv.TvInputInfo)> -> _SOURCE_
android.permission.TV_INPUT_HARDWARE
<com.android.server.tv.TvInputManagerService.ServiceCallback: void removeTvInput(java.lang.String)> -> _SOURCE_
android.permission.TV_INPUT_HARDWARE
<com.android.server.wallpaper.WallpaperManagerService: void clearWallpaper(java.lang.String)> -> _SOURCE_
android.permission.SET_WALLPAPER
<com.android.server.wallpaper.WallpaperManagerService: void setDimensionHints(int,int,java.lang.String)> -> _SOURCE_
android.permission.SET_WALLPAPER_HINTS
<com.android.server.wallpaper.WallpaperManagerService: void setDisplayPadding(android.graphics.Rect,java.lang.String)> -> _SOURCE_
android.permission.SET_WALLPAPER_HINTS
<com.android.server.wallpaper.WallpaperManagerService: android.os.ParcelFileDescriptor setWallpaper(java.lang.String,java.lang.String)> -> _SOURCE_
android.permission.SET_WALLPAPER
<com.android.server.wallpaper.WallpaperManagerService: void setWallpaperComponent(android.content.ComponentName)> -> _SOURCE_
android.permission.SET_WALLPAPER_COMPONENT
<com.android.server.wallpaper.WallpaperManagerService: void setWallpaperComponentChecked(android.content.ComponentName,java.lang.String)> -> _SOURCE_
android.permission.SET_WALLPAPER_COMPONENT
<com.android.server.wm.WindowManagerService: void addAppToken(int,android.view.IApplicationToken,int,int,int,boolean,boolean,int,int,boolean,boolean)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void addWindowToken(android.os.IBinder,int)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void clearForcedDisplayDensity(int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.wm.WindowManagerService: void clearForcedDisplaySize(int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.wm.WindowManagerService: boolean clearWindowContentFrameStats(android.os.IBinder)> -> _SOURCE_
android.permission.FRAME_STATS
<com.android.server.wm.WindowManagerService: void disableKeyguard(android.os.IBinder,java.lang.String)> -> _SOURCE_
android.permission.DISABLE_KEYGUARD
<com.android.server.wm.WindowManagerService: void dismissKeyguard()> -> _SOURCE_
android.permission.DISABLE_KEYGUARD
<com.android.server.wm.WindowManagerService: void executeAppTransition()> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void exitKeyguardSecurely(android.view.IOnKeyguardExitResult)> -> _SOURCE_
android.permission.DISABLE_KEYGUARD
<com.android.server.wm.WindowManagerService: void freezeRotation(int)> -> _SOURCE_
android.permission.SET_ORIENTATION
<com.android.server.wm.WindowManagerService: android.view.WindowContentFrameStats getWindowContentFrameStats(android.os.IBinder)> -> _SOURCE_
android.permission.FRAME_STATS
<com.android.server.wm.WindowManagerService: boolean isViewServerRunning()> -> _SOURCE_
android.permission.DUMP
<com.android.server.wm.WindowManagerService: void keyguardGoingAway(boolean,boolean)> -> _SOURCE_
android.permission.DISABLE_KEYGUARD
<com.android.server.wm.WindowManagerService: void lockNow(android.os.Bundle)> -> _SOURCE_
android.permission.DEVICE_POWER
<com.android.server.wm.WindowManagerService: void pauseKeyDispatching(android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void prepareAppTransition(int,boolean)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void reenableKeyguard(android.os.IBinder)> -> _SOURCE_
android.permission.DISABLE_KEYGUARD
<com.android.server.wm.WindowManagerService: void removeAppToken(android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void removeWindowToken(android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: boolean requestAssistScreenshot(com.android.internal.app.IAssistScreenshotReceiver)> -> _SOURCE_
android.permission.READ_FRAME_BUFFER
<com.android.server.wm.WindowManagerService: void resumeKeyDispatching(android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: android.graphics.Bitmap screenshotApplications(android.os.IBinder,int,int,int)> -> _SOURCE_
android.permission.READ_FRAME_BUFFER
<com.android.server.wm.WindowManagerService: void setAnimationScale(int,float)> -> _SOURCE_
android.permission.SET_ANIMATION_SCALE
<com.android.server.wm.WindowManagerService: void setAnimationScales([float)> -> _SOURCE_
android.permission.SET_ANIMATION_SCALE
<com.android.server.wm.WindowManagerService: void setAppOrientation(android.view.IApplicationToken,int)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void setAppStartingWindow(android.os.IBinder,java.lang.String,int,android.content.res.CompatibilityInfo,java.lang.CharSequence,int,int,int,int,android.os.IBinder,boolean)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void setAppTask(android.os.IBinder,int)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void setAppVisibility(android.os.IBinder,boolean)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void setAppWillBeHidden(android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void setEventDispatching(boolean)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void setFocusedApp(android.os.IBinder,boolean)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void setForcedDisplayDensity(int,int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.wm.WindowManagerService: void setForcedDisplayScalingMode(int,int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.wm.WindowManagerService: void setForcedDisplaySize(int,int,int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.wm.WindowManagerService: void setNewConfiguration(android.content.res.Configuration)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void setOverscan(int,int,int,int,int)> -> _SOURCE_
android.permission.WRITE_SECURE_SETTINGS
<com.android.server.wm.WindowManagerService: void startAppFreezingScreen(android.os.IBinder,int)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void startFreezingScreen(int,int)> -> _SOURCE_
android.permission.FREEZE_SCREEN
<com.android.server.wm.WindowManagerService: boolean startViewServer(int)> -> _SOURCE_
android.permission.DUMP
<com.android.server.wm.WindowManagerService: void statusBarVisibilityChanged(int)> -> _SOURCE_
android.permission.STATUS_BAR
<com.android.server.wm.WindowManagerService: void stopAppFreezingScreen(android.os.IBinder,boolean)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
<com.android.server.wm.WindowManagerService: void stopFreezingScreen()> -> _SOURCE_
android.permission.FREEZE_SCREEN
<com.android.server.wm.WindowManagerService: boolean stopViewServer()> -> _SOURCE_
android.permission.DUMP
<com.android.server.wm.WindowManagerService: void thawRotation()> -> _SOURCE_
android.permission.SET_ORIENTATION
<com.android.server.wm.WindowManagerService: android.content.res.Configuration updateOrientationFromAppTokens(android.content.res.Configuration,android.os.IBinder)> -> _SOURCE_
android.permission.MANAGE_APP_TOKENS
